from __future__ import annotations

"""Unified models namespace – contains both API (request/response) and DB models.

All FastAPI route models, enums and helpers live directly in this package so
call-sites can simply::

    from app.models import PolicyBundleResponse, PlanTier, APITokenResponse

Legacy imports like ``from app.schemas import …`` are still supported via a thin
re-export shim in ``app/schemas/__init__.py``.
"""

from datetime import datetime
from enum import Enum
from importlib import import_module
from typing import Any, Dict, List, Optional
from dataclasses import dataclass

from pydantic import BaseModel, Field

# External enums -------------------------------------------------------------
from app.models.scopes import Scope

# ---------------------------------------------------------------------------
# Authentication Models
# ---------------------------------------------------------------------------

@dataclass
class AuthContext:
    """Authentication context from validated API token.
    
    This replaces the old pattern of storing auth data in request.state
    and makes authentication data explicit and type-safe.
    """
    account_id: str
    scopes: list[str]
    user_id: str | None = None
    token_id: str | None = None
    app_name: str | None = None
    
    def has_scope(self, scope: str) -> bool:
        """Check if the token has a specific scope."""
        return scope in self.scopes or "admin" in self.scopes
    
    def has_any_scope(self, *scopes: str) -> bool:
        """Check if the token has any of the given scopes."""
        return any(self.has_scope(scope) for scope in scopes)
    
    def is_admin(self) -> bool:
        """Check if this is an admin token."""
        return "admin" in self.scopes
    
    def is_dev(self) -> bool:
        """Check if this is a dev token."""
        return "dev" in self.scopes

# ---------------------------------------------------------------------------
# Enums – shareable across request / DB models
# ---------------------------------------------------------------------------

class PlanTier(str, Enum):
    trial = "trial"
    essentials = "essentials"
    pro = "pro"
    enterprise = "enterprise"

class AuditAction(str, Enum):
    """Standardized audit action types for comprehensive logging."""
    # Token operations
    token_create = "token.create"
    token_revoke = "token.revoke"
    token_rotate = "token.rotate"
    
    # Policy operations
    policy_draft = "policy.draft"
    policy_publish = "policy.publish"
    policy_update = "policy.update"
    policy_revert = "policy.revert"
    policy_revoke = "policy.revoke"
    
    # Key operations
    key_upload = "key.upload"
    key_revoke = "key.revoke"
    
    # SDK telemetry operations
    tool_invocation = "tool.invocation"
    auth_decision = "auth.decision"
    policy_poll = "policy.poll"
    policy_load = "policy.load"
    jwks_fetch = "jwks.fetch"
    context_leak = "context.leak"
    missing_policy = "missing.policy"
    sync_in_async_denied = "sync_in_async.denied"
    
    # Threading security operations (NEW 2025-08-28)
    context_submission = "context.submission"
    context_missing_actor = "context.missing_actor"
    context_leak_detected = "context.leak_detected"
    context_actor_override = "context.actor_override"
    thread_entrypoint = "thread.entrypoint"
    context_no_context_error = "context.no_context_error"
    
    # Invitation operations
    invitation_create = "invitation.create"
    invitation_accept = "invitation.accept"
    invitation_cancel = "invitation.cancel"

class AuditStatus(str, Enum):
    """Status of audited operations."""
    success = "success"
    failure = "failure"
    denied = "denied"
    allowed = "allowed"
    
    # Threading security statuses (NEW 2025-08-28)
    context_violation = "context_violation"  # Missing actor, context leaks
    security_override = "security_override"  # Actor overrides, confused deputy
    context_hygiene = "context_hygiene"     # Context cleanup issues

# ---------------------------------------------------------------------------
# API  Pydantic models (previously in app.schemas)
# ---------------------------------------------------------------------------

class BaseResponse(BaseModel):
    class Config:
        orm_mode = True
        json_schema_extra = {"example": {"message": "OK"}}

class MessageResponse(BaseResponse):
    message: str = Field(..., example="OK")

class PolicyBundleResponse(BaseModel):
    jws: Optional[str] = Field(None, description="Signed bundle (None when draft)")
    version: int
    etag: str
    bundle: Optional[Dict[str, Any]] = Field(None, description="Raw bundle content (included for drafts)")

class PolicyDraft(BaseModel):
    bundle: Dict[str, Any] = Field(..., description="Raw policy document")
    # version is now auto-generated by the backend

class PolicyPublishResponse(BaseModel):
    jws: str
    version: int

class PolicyVersionResponse(BaseModel):
    id: str = Field(..., description="Policy ID")
    version: int = Field(..., description="Policy version number")
    active: bool = Field(..., description="Whether this version is currently active")
    published_at: datetime = Field(..., description="When this version was published")
    expires: Optional[datetime] = Field(None, description="When this policy expires")
    revocation_time: Optional[datetime] = Field(None, description="When this version was revoked")
    app_name: str = Field(..., description="App name for this policy")
    description: Optional[str] = Field(None, description="Policy description")
    bundle: Optional[Dict[str, Any]] = Field(None, description="Policy bundle content (for comparison)")
    published_by: Optional[str] = Field(None, description="Name of user who published this version")

class PolicyRevertRequest(BaseModel):
    policy_id: str = Field(..., description="ID of the policy version to revert to")

class MeResponse(BaseModel):
    plan: str
    trial_expires: Optional[datetime] = None
    quotas: Dict[str, int] = Field(default_factory=dict, description="Plan quota limits")
    metrics_enabled: bool
    poll_seconds: int

class EventsBatch(BaseModel):
    events: List[Dict[str, Any]]

class APIKeyDB(BaseModel):
    token_id: str
    account_id: str
    scopes: List[str]
    expires_at: Optional[datetime]
    revoked_at: Optional[datetime]

class TokenCreateRequest(BaseModel):
    token_name: Optional[str] = Field(None, description="Friendly label for the token")
    scopes: Optional[List[Scope]] = Field(
        default_factory=lambda: [Scope.read],
        description="Token capability scopes",
    )
    app_name: Optional[str] = Field(None, description="Associate token with specific app")
    assigned_user_id: Optional[str] = Field(None, description="Assign token to specific user (defaults to current user)")

class TokenCreateResponse(BaseModel):
    token_id: str
    token: str  # plaintext token (returned only once)
    scopes: List[str]
    expires_at: Optional[datetime]

class APITokenResponse(BaseModel):
    token_id: str
    scopes: List[str]
    expires_at: Optional[datetime]
    revoked_at: Optional[datetime]
    token_name: Optional[str] = None
    created_at: Optional[datetime] = None
    created_by_name: Optional[str] = None

class TokenRevokeRequest(BaseModel):
    token_id: str = Field(..., description="Token ID to revoke")

class SignupRequest(BaseModel):
    name: str
    plan: PlanTier = Field(default=PlanTier.trial, description="Initial plan tier")

class SignupResponse(BaseModel):
    account_id: str
    admin_token: str

# Event model ---------------------------------------------------------------
from app.models.events import EventIngest  # noqa: E402

# Basic User model used by security_utils
class User(BaseModel):  # noqa: D101 – simple data carrier
    id: str
    email: Optional[str] = None
    full_name: Optional[str] = None

class PublicKeyAddRequest(BaseModel):
    key_id: Optional[str] = Field(None, description="Unique identifier for the key")
    public_key: str = Field(..., description="Base64-encoded Ed25519 public key")

class PublicKeyResponse(BaseModel):
    key_id: str
    algo: str = Field(default="ed25519")
    public_key: str = Field(..., description="Base64-encoded Ed25519 public key")
    created_at: datetime
    revoked_at: Optional[datetime]
    user_id: Optional[str] = Field(None, description="User who uploaded this key")
    uploaded_by_name: Optional[str] = Field(None, description="Display name of user who uploaded this key")
    

class AccountCreateResponse(BaseModel):
    """Returned by the (now optional) account-bootstrap endpoint."""

    account_id: str

class TokenScopeError(BaseModel):
    """403 response for insufficient token scope."""

    error: str = Field("insufficient_scope", pattern="^insufficient_scope$")

# Add new request model for app rename


# ---------------------------------------------------------------------------
# Re-export DB row models
# ---------------------------------------------------------------------------

_db = import_module("app.models.db")

# Merge symbols into current module globals so consumers can ``import app.models as m``
_globals_update = {k: getattr(_db, k) for k in getattr(_db, "__all__", [])}
_globals_update.update(globals())
globals().update(_globals_update)

# Build __all__
__all__: list[str] = list(_globals_update.keys()) 


class PolicyDescriptionUpdate(BaseModel):
    """Payload for updating a policy description from the dashboard."""
    description: str = Field(..., max_length=1024)

class PolicyBundleUpdate(BaseModel):
    """Payload for updating a policy bundle content from the editor."""
    bundle: Dict[str, Any] = Field(..., description="Updated policy bundle content")
    description: Optional[str] = Field(None, max_length=1024, description="Optional description update")

class PolicyValidationRequest(BaseModel):
    """Request for validating a policy bundle in the editor."""
    bundle: Dict[str, Any] = Field(..., description="Policy bundle to validate")

class PolicyValidationResponse(BaseModel):
    """Response for policy validation with detailed feedback."""
    valid: bool = Field(..., description="Whether the policy is valid")
    errors: List[str] = Field(default_factory=list, description="Validation error messages")
    warnings: List[str] = Field(default_factory=list, description="Validation warnings")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Extracted metadata from bundle") 


class PolicySummary(BaseModel):
    id: str
    app_name: str
    version: int
    description: str | None = None
    active: bool
    is_draft: bool
    published_at: datetime | None = None
    expires: datetime | None = None
    revocation_time: datetime | None = None
    is_revoked: bool = False
    bundle: dict | None = None


class EventRecord(BaseModel):
    id: str
    occurred_at: datetime
    event_type: str
    payload: dict
    ingested_at: datetime
    host: str | None = None
    source_ip: str | None = None

class AuditLogRecord(BaseModel):
    id: int
    actor_id: str
    token_id: str | None = None
    user_id: str | None = None
    action: str
    key_id: str | None = None
    version: int | None = None
    created_at: datetime